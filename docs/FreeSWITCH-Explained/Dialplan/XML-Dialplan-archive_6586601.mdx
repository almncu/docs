# XML Dialplan 归档

## 关于

（本页是从旧维基复制的原始文档。文档团队目前正在将其合并到改进后的 [XML Dialplan 页面](./XML-Dialplan/index.mdx#about)。）XML dialplan 是 FreeSwitch 默认使用的拨号计划。

[点击此处展开目录]()

* 1 [介绍](#introduction)
* 2 [总览](#the-10000-foot-view)
* 3 [拨号计划配置目录结构](#dialplan-configuration-directory-structure)
* 4 [XML拨号计划的结构](#anatomy-of-the-xml-dialplan)
   * 4.1 [上下文](#context)
   * 4.2 [扩展](#extensions)
   * 4.3 [条件](#conditions)
   * 4.4 [变量](#variables)
   * 4.5 [动作和反动作](#actions-and-anti-actions)
   * 4.6 [完整语法](#complete-syntax)
   * 4.7 [简要总结](#short-summary)
* 5 [其他拨号计划的要点](#other-dialplan-pearls-of-wisdom)
   * 5.1 [自动群发](#auto-hunt)
   * 5.2 [通过网关拨号](#dialing-through-gateways)
* 6 [示例](#examples)
   * 6.1 [示例1：匹配条件](#example-1-matching-a-condition)
   * 6.2 [示例2：匹配多个条件（AND）](#example-2-matching-multiple-conditions-and)
   * 6.3 [示例3：去除前导数字](#example-3-stripping-leading-digits)
   * 6.4 [示例4：添加前缀](#example-4-adding-a-prefix)
   * 6.5 [示例5：SIP配置文件（使用不同的配置拨号）](#example-5-sip-profiles-dialing-with-different-configurations)
   * 6.6 [示例6：呼叫已注册用户](#example-6-calling-registered-user)
   * 6.7 [示例7：动作故障转移](#example-7-action-failover-on-failed-action)
   * 6.8 [示例8：检查用户是否已被认证](#example-8-check-user-is-authenticated)
   * 6.9 [示例9：将DID路由到分机](#example-9-routing-did-to-an-extension)
   * 6.10 [示例10：将路由到具有自定义呼叫者ID的网关分机](#example-10-route-to-a-gateway-extension-with-custom-caller-id)
   * 6.11 [示例11：基于号码前缀进行路由](#example-11-route-based-on-number-prefix)
   * 6.12 [示例12：处理没有匹配扩展的呼叫](#example-12-handle-calls-which-match-no-extension)
   * 6.13 [示例13：呼叫筛选](#example-13-call-screening)
   * 6.14 [示例14：媒体录音](#example-14-media-recording)
   * 6.15 [示例15：讲述时钟](#example-15-speaking-clock)
   * 6.16 [示例16：屏蔽特定代码](#example-16-block-certain-codes)
   * 6.17 [示例17：从入局DID接收传真](#example-17-receive-fax-from-inbound-did)
   * 6.18 [示例18：在传入BRI呼叫上为effective_caller_id_number添加国际呼叫前缀](#example-18-add-international-call-prefix-to-effective_caller_id_number-on-incoming-bri-calls)
   * 6.19 [示例19：DISA](#example-19-disa)
   * 6.20 [示例20：修复无效的呼叫者ID](#example-20-fix-invalid-caller-id)
   * 6.21 [示例21：阻止呼出呼叫者ID](#example-21-block-outbound-caller-id)
   * 6.22 [示例22：在进行数据库查询期间播放MOH](#example-22-play-moh-while-doing-a-database-lookup)
* 7 [SIP特定的拨号字符串](#sip-specific-dialstrings)
   * 7.1 [拨打SIP URI](#dialing-a-sip-uri)
   * 7.2 [拨打已注册的用户](#dialing-a-registered-user)
   * 7.3 [通过网关拨打（SIP提供者）](#dialing-through-a-gateway-sip-provider)
   * 7.4 [使用特定传输方式拨打](#dialing-with-a-specific-transport)
   * 7.5 [指定编解码器](#specifying-the-codec)
   * 7.6 [使用PortAudio玩得开心](#getting-fancy-with-portaudio)
   * 7.7 [更改SIP联系人用户](#changing-the-sip-contact-user)
   * 7.8 [使用自定义SIP URI](#using-a-custom-sip-uri)
   * 7.9 [使用命令行测试拨号计划](#testing-the-dialplan-with-a-command-line)
   * 7.10 [为呼叫转移设置SIP Diversion Header](#setting-up-sip-diversion-header-for-call-forward)
* 8 [相关](#related)

### 介绍

XML拨号计划是FreeSwitch默认使用的拨号计划。XML可以通过手工编辑而不需要特殊工具，只需一个文本编辑器即可。

拨号计划用于将拨打的电话路由到相应的端点，可以是传统分机、语音信箱、交互式语音应答(IVR)菜单或其他兼容的应用程序。拨号计划非常灵活。

拨号计划可以分成不同的'上下文'，允许您为不同类型的呼叫拥有单独的拨号计划。呼叫也可以被转到不同的上下文。例如，为了方便安全考虑，您可能会有两个拨号计划，一个处理来自公共电话网络(PSTN)的呼叫，另一个处理来自内部分机的呼叫。FreeSwitch的示例配置文件使用这种方法，在将到达的PSTN呼叫交给内部拨号计划之前经过额外的审核。拨号计划上下文的另一个用途是允许您在办公大楼中与多个租户共享单个PBX。由于每个租户可能都有自己的(经常冲突的)分机、语音菜单等，将租户分开到自己的独立拨号计划中可以方便配置和维护。

XML拨号计划使用标准化的Perl [正则表达式](https://wiki.freeswitch.org/wiki/Regular%5FExpression "Regular Expression")来匹配字段，这减少了有经验的Perl用户创建和维护拨号计划的"学习曲线"。要理解这份文档，需要了解[正则表达式](https://wiki.freeswitch.org/wiki/Regular%5FExpression "Regular Expression")。

### 概览

本概览以[Sofia](https://wiki.freeswitch.org/wiki/Sofia "Sofia") SIP驱动程序作为拨号计划处理的呼叫源和目标。其他驱动程序有类似的机制。

当呼叫到达FreeSWITCH时，Sofia是第一个响应者。它收集关于呼叫的信息，并决定要调用哪个拨号计划。

Sofia将呼叫的信息以'通道变量'的形式传递给适当的拨号计划，也就是所谓的拨号计划 'context'。

拨号计划根据通道变量来确定如何处理呼叫。它通过遍历拨号计划中设定的一系列可能的匹配 '条件'来实现这一点。如果找到匹配项，将运行一组匹配的拨号计划 '应用程序' 来处理呼叫。应用程序可以包括将呼叫控制转移到另一个拨号计划，将呼叫连接到分机，语音邮件系统，[IVR](https://wiki.freeswitch.org/wiki/IVR "IVR")等，或任何集成到FreeSWITCH中的其他应用程序。

要调用您的拨号计划，关键是在[Sofia配置文件](https://wiki.freeswitch.org/wiki/Sofia.conf.xml "Sofia.conf.xml")中使用以下XML元素。

```xml
<param name="context" value="public"/>
```

### 拨号计划配置目录结构

FreeSWITCH示例配置将拨号计划存储在conf/dialplans目录中，每个上下文存储在其下的子目录中。这是推荐的配置。

例如，这个示例结构包含了一个简单PBX的拨号计划：

```xml
freeswitch/
    conf/
        dialplans/
            public.xml
            public/
                00_security_screen.xml
                10_inbound_sip-bandwidth-r-us.xml
                29_inbound_sip-super-call.xml
                ...
            default.xml
            default/
                00_feature_codes.xml
                05_voicemail_access.xml
                20_extension_2001.xml
                20_extension_2002.xml
                ...
```

需要注意以下几点:

* 这个拨号计划结构与FreeSWITCH附带的示例配置类似。作为自定义自己PBX的好起点，就像我们在这里所做的一样。
* 将任何.xml文件放置在dialplans目录中，FreeSWITCH启动时都会被加载。这不是魔法，这是默认配置的加载方式。
* public.xml包含公共上下文的所有常见配置信息，然后包含public目录中的所有XML文件。
* default.xml包含默认上下文的所有常见配置信息，然后包含default目录中的所有XML文件。
* 文件按字母顺序被包含，因此以数字开头的文件名是确保拨号计划的各个部分按照正确顺序处理的好做法。

### XML拨号计划的结构

构建XML拨号计划需要使用几个元素。通常，拨号计划将逻辑上相似的功能和呼叫活动分组到一个“上下文”中。在一个上下文中，有多个扩展，每个扩展都有“条件”规则和相关的“操作”，当条件规则匹配时执行这些操作。

以下是一个示例拨号计划，用于说明这些概念。为了更清楚地理解基本概念，我们省略了XML的“包装器”：

```xml
<context name="example">
    <extension name="500">
        <condition field="destination_number" expression="^500$">
            <action application="bridge" data="user/500"/> 
        </condition>
    </extension>
 
    <extension name="501">
        <condition field="destination_number" expression="^501$">
            <action application="bridge" data="user/501"/>
            <action application="answer"/>
            <action application="sleep" data="1000"/>
            <action application="bridge" data="loopback/app=voicemail:default ${domain_name} ${dialed_extension}"/>
        </condition>
    </extension>
</context>
```

按顺序处理每个规则，直到达到指示FreeSWITCH执行何种操作的动作标签。对于给定的扩展，您不仅限于一个条件或一个动作标签。

在我们上面的示例中，对扩展501的呼叫会响铃扩展。如果用户没有回答，第二个动作接听来电，并且后续动作会延迟1000毫秒（即1秒），并将通话连接到语音邮件系统。

#### 上下文

上下文是扩展的逻辑分组。您可以在一个上下文中包含多个扩展。

上下文标签有一个必需的'name'参数。有一个保留的名称"any"，它与任何上下文匹配。这个名称被呼入调用处理程序（比如\[Sofia\] SIP驱动程序）用于选择在需要路由呼叫时运行的拨号计划。一个拨号计划中通常会有多个上下文。

下面是一个完全合格的上下文定义。通常情况下，您不需要这么多内容，但是为了完整起见，在这里展示出来。

```xml
<?xml version="1.0"?>
    <document type="freeswitch/xml">
        <section name="dialplan" description="正则表达式/XML拨号计划">
        <!-- 默认上下文是一个安全的起点 -->
            <context name="default">
                <!-- 一个或多个扩展标签 -->
            </context>
            <!-- 更多可选的上下文 -->
        </section>
    </document>
```

#### 扩展

扩展是呼叫的目的地。这是FreeSWITCH路由拨号号码的核心功能。它们被赋予一个名称，并包含一组条件，如果满足这些条件，将执行某些操作。

'replace[x]'参数是必需的：它必须是一个唯一的名称，用于标识和后续使用。

例如：

```xml
<extension name="在这里填写您的扩展名">
    <condition(s)...
        <action(s) .../>
    </condition>
</extension>
```

通常情况下，当在拨号计划中匹配到一个扩展时，将执行相应的操作并停止拨号计划处理。一个可选的'continue'参数允许拨号计划继续运行。

```xml
<extension name="500" continue="true">
```

#### 条件

拨号计划条件通常用于将目标号码与扩展匹配。然而，它们比表面上看起来的更强大。

FreeSWITCH有一组用于测试的内置变量。在这个示例中，内置变量`destination_number`与正则表达式`^500$`进行比较。如果`<destination_number>`设置为500，则比较结果为“true”。条件

拨号计划条件通常用于将目标号码与分机号进行匹配。然而，它们比表面上看起来要强大得多。

```xml
<extension name="500">
    <condition field="destination_number" expression="^500$">
        <action application="bridge" data="user/500"/> 
    </condition>
</extension>
```

每个条件都使用Perl兼容的正则表达式库进行解析。（请点击[这里](http://perldoc.perl.org/perlre.html)获取有关PCRE语法的信息）。

如果正则表达式中包含括在括号中的任何项，并且表达式匹配成功，那么变量$1，$2..$N将被设置为括号内匹配的内容，并可以在此扩展块内的后续操作标签中使用。目前似乎只能使用不超过$9个变量。

例如，这个简单的表达式匹配一个四位数的分机号，并将最后两位数字捕获到$1中。

```xml
<condition field="destination_number" expression="^\d\d(\d\d)$">
    <action application="bridge" data="sofia/internal/$1@example.com"/>
</condition>
```

目标号码3425将设置$1为25，然后将呼叫桥接到[25@example.com](mailto:25@example.com)上的电话

如果$N之后是一个数字，则变量可以使用大括号括起来：${N}。例如：

```xml
<condition field="destination_number" expression="^\d\d(\d\d)$">
    <action application="bridge" data="sofia/internal/${1}0@example.com"/>
</condition>
```

##### 多个条件（逻辑AND）

在许多编程语言中，您可以使用多个条件来模拟逻辑与操作。

当您在扩展中放置多个条件时，_所有_条件必须匹配才能执行操作。

例如，只有当目标号码为500 _并且_ 是星期天时，此代码块才会执行操作。

```xml
<condition field="destination_number" expression="^500$"/>
<condition wday="1">
    action(s)...
</condition>
```

请注意，使用此结构时必须遵守正确的 XML 语法。务必使用 /> 闭合除了最后一个以外的所有条件。最后一个条件包含要运行的最终操作，并在最后一个操作的下一行关闭。

默认情况下，如果任何条件为假，FreeSWITCH 将继续执行反动作或下一个扩展，甚至不会评估其他条件。

##### 嵌套条件

最近添加。参见 <http://jira.freeswitch.org/browse/FS-4935>

嵌套条件中的新属性是 "require-nested"，它是 true 或 false，并指示嵌套条件在执行嵌套条件上层的其他操作时是否必须评估为真。

因此，在下面的例子中，如果 "require-nested" 为 true，默认为 true 即使未明确指定，则子条件必须为真，或以与顶层扩展相同的方式设置了 break=never。基本上，每个级别的嵌套条件都使用与解析扩展相同的方法进行解析，只是使用上述描述的 "require-nested" 逻辑替代了 continue。

如果 require-nested 为 false，则无论嵌套条件中发生什么，即使完全失败，它也将传递给父级中的下一个操作。

```xml
<extension name="nested_example">
  <condition field="destination_number" expression="^1234$" require-nested="true">

    <condition field="destination_number" expression="3">
      <action application="playback" data="foo.wav" />
    </condition>

    <action application="playback" data="bar.wav" />

  </condition
</extension>
```

基本上，通过这个逻辑组合，您应该能够使用"require-nested=false"来进行一个主要的条件，然后是一系列实现逻辑AND的嵌套条件。

```xml
<extension name="nested_example">
  <condition field="destination_number" expression="^1234$" require-nested="false">

    <condition field="f1" expression="e1"/>
    <condition field="f2" expression="e2"/>
    <condition field="f3" expression="e3"/>
    <condition field="destination_number" expression="3" break="never">
      <action application="playback" data="foo.wav" />
    </condition>

    <action application="playback" data="bar.wav" />

  </condition
</extension>
```

###### 嵌套条件的注意事项

首先要记住的是，当解析器找到一个带有嵌套子条件的条件时，它总是会先解析子条件！这意味着您不能这样做：

```xml
<extension name="nested_example">
  <condition field="destination_number" expression="^1234$" require-nested="false">
    <action application="log" data="INFO I'm before the nested conditions..."/>

    <condition field="${foo1}" expression="bar1" break="never">
      <action application="log" data="INFO foo1 is bar1" />
    </condition>

    <action application="log" data="INFO I'm in between the nested conditions..."/>
```

```xml
<条件 字段="${foo2}" 表达式="bar2" 中断="永不">
  <操作 应用="日志" 数据="INFO foo2 是 bar2" />
</条件>

<操作 应用="日志" 数据="INFO 我在嵌套的条件之后..." />

</条件>
</扩展>
```

这不会达到你的期望。相反，它将按照以下顺序执行这些行：

```xml
<操作 应用="日志" 数据="INFO foo1 是bar1" />
<操作 应用="日志" 数据="INFO foo2 是bar2" />
<操作 应用="日志" 数据="INFO 我在嵌套的条件之前..." />
<操作 应用="日志" 数据="INFO 我在嵌套的条件中间..." />
<操作 应用="日志" 数据="INFO 我在嵌套的条件之后..." />
```

所以，记住：子元素优先！它们的操作/反操作将在父元素之前被处理和添加到任务列表中。

另一个重要注意事项：捕获 $1、$2 等是有效的:

```xml
<扩展 名称="本地扩展">
  <条件 字段="目标号码" 表达式="^($${extension_regex})$" 需要嵌套="false">
    <条件 字段="主叫方号码" 表达式="^(.*)$">
      <操作 应用="日志" 数据="警告 在嵌套条件中，呼叫者号码是 $1"/>
    </条件>
    <操作 应用="日志" 数据="通知 你能看见我吗？"/>
    <条件 字段="主叫方名称" 表达式="^(.*)$">
      <操作 应用="日志" 数据="警告 在嵌套条件中，呼叫者名称是 $1"/>
    </条件>
    <操作 应用="日志" 数据="警告 目标号码是 $1"/>
    ...
```

上面的代码将正常工作。记住这两点，你就能在你的拨号计划中做出各种有趣的东西！
##### 多个条件（逻辑或、逻辑异或）

可以使用多个条件来模拟许多编程语言中提供的逻辑OR操作。在这种情况下，如果其中一个条件匹配，就会执行相应的操作。

例如，如果目标号码是501或者目标号码是502，那么下面的代码块将执行其操作。

```xml
<condition field="destination_number" expression="^501|502$">
    action(s)...
</condition>
```

如果你的OR条件是针对同一个字段，这种方法效果很好。但是，如果你需要使用两个或更多不同的字段，那么可以使用新增于2011年11月1日的**regex**语法。具体如下所示：

```xml
<condition regex="all|any|xor">
  <regex field="some_field" expression="Some Value"/>
  <regex field="another_field" expression="^Another\s*Value$"/>
  <action(s) ...>
  <anti-action(s)...>
</condition>
```

regex条件可以有三个值：

* all — 等同于逻辑AND操作。条件中包含的**所有**表达式都必须为真，才会执行相应的操作。
* any — 等同于逻辑OR操作。条件中包含的**任何一个**表达式为真，都会执行相应的操作。
* xor — 等同于逻辑XOR操作。只允许**一个**表达式为真，才会执行相应的操作。

操作和反向操作的执行方式与标准的_condition_块相同。

例如，下面的代码块将检查主叫号码的名称和号码，并且如果名称是"Some User" **或者** 号码是1001，就执行相应的操作：

```xml
<extension name="正则表达式或条件示例1" continue="true">
    <condition regex="any">
      <!-- 如果其中任一条件为真，则将后续操作添加到执行列表中 -->
      <regex field="caller_id_name" expression="Some User"/>
      <regex field="caller_id_number" expression="^1001$"/>
      <action application="log" data="INFO 至少有一个条件匹配！"/>
      <!-- 如果没有任何正则表达式为真，则将反操作添加到执行列表中 -->
      <anti-action application="log" data="WARNING 没有任何条件匹配！"/>
    </condition>
  </extension> 
```

这种方法使匹配呼叫者姓名 _或_ 呼叫者ID号更加简单，并且在任一条件为真时执行操作。

下面是对该方法的稍微高级一点的使用示例。如果呼叫者姓名为"Michael S Collins" **或** 呼叫者ID号为1002、3757或2816，则将变量 `calling_user`设置为"mercutioviz"。如果两者都不为真，则将变量 `calling_user` 设置为"loser"。在播放欢迎消息之后，根据 `calling_user` 变量播放自定义消息。

```xml
<extension name="正则表达式或者示例2" continue="true">
    <condition regex="any" break="never">
      <regex field="caller_id_name" expression="^Michael\s*S?\s*Collins"/>
      <regex field="caller_id_number" expression="^1001|3757|2816$"/>
      <action application="set" data="calling_user=mercutioviz" inline="true"/>
      <anti-action application="set" data="calling_user=loser" inline="true"/>
    </condition>
 
    <condition>
      <action application="answer"/>
      <action application="sleep" data="500"/>
      <action application="playback" data="ivr/ivr-welcome_to_freeswitch.wav"/>
      <action application="sleep" data="500"/>
    </condition>
 
    <condition field="${calling_user}" expression="^loser$">
      <action application="playback" data="ivr/ivr-dude_you_suck.wav"/>
      <anti-action application="playback" data="ivr/ivr-dude_you_rock.wav"/>
    </condition>
  </extension> 
```

下一个示例展示了如何创建一个异或（exclusive-or）条件块，当只有一个条件为真时，该条件块为真

```xml
  <extension name="正则表达式异或示例3" continue="true">
    <condition regex="xor">
      <!-- 如果只有一个条件为真，则随后的操作将被添加到执行列表 -->
      <regex field="caller_id_name" expression="Some User"/>
      <regex field="caller_id_number" expression="^1001$"/>
      <action application="log" data="INFO 只有一个条件匹配！"/>
      <!-- 如果没有一个正则表达式为真，则反操作将被添加到执行列表 -->
      <anti-action application="log" data="WARNING 没有一个条件匹配！"/>
    </condition>
  </extension> 
```

另一个示例展示了如何确保在执行动作之前所有表达式都匹配，否则将执行反动作。在这种情况下，SIP网关必须是默认提供者，并且必须是紧急呼叫，同时自动应答选项必须启用并存储在数据库中：

```xml
<condition regex="all">
  <regex field="${sip_gateway}" expression="^${default_provider}$"/>
  <regex field="${emergency_call}" expression="^true$"/>
  <regex field="${db(select/emergency/autoanswer)}" expression="^1$"/>

  <!-- 如果所有正则表达式匹配成功，执行以下动作 -->
   <action application="set" data="call_timeout=60"/>
   <action application="set" data="effective_caller_id_name=${regex(${caller_id_name}|^Emerg(_.*)$|Auto%1)}"/>
   <action application="set" data="autoanswered=true"/>
   <action application="bridge" data="user/1000@${domain_name},sofia/gateway/1006_7217/${mobile_number}"/>

  <!-- 如果任何正则表达式匹配失败，则执行以下反动作 -->
   <anti-action application="set" data="effective_caller_id_name=${regex(${caller_id_name}|^Emerg(_.*)$|NotAuto%1)}"/>
   <anti-action application="set" data="call_timeout=30"/>
   <anti-action application="set" data="autoanswered=false"/>
   <anti-action application="bridge" data="user/1000@${domain_name},sofia/gateway/1006_7217/${mobile_number}"/>
 </condition>
```

如果在正则表达式中使用 ( ) 运算符捕获数据，则在展开捕获时（使用 $n 语法）只会考虑遇到的最后一个捕获的数据。[_这是什么意思？_ 另外，您可以使用 DP_REGEX_MATCH_1 .. DP_REGEX_MATCH_N 将捕获保存到数组中。_]

##### 复杂的条件/动作规则

这是一个更复杂的例子，用于支持部门的时间路由。用户拨打分机号1100。实际的支持分机号是1105，每天早上8点到晚上10点有人接听，周五的接听时间是早上8点到下午1点。其他时间拨打1100会转接到售后信箱。

注意，break="on-false" 是默认设置。

```xml
<extension name="Time-of-day-tod">
    <!--如果条件为false，FreeSWITCH会跳转到下一个extension。-->
    <condition field="destination_number" expression="^1100$" break="on-false"/>

    <!--如果条件为true，不再继续评估接下来的条件集。-->
    <condition wday="6" hour="8-12" break="on-true">    <!--周五，早上8点-下午12点59分-->
        <action application="transfer" data="1105 XML default"/>
    </condition>

    <condition wday="1-5" hour="8-21" break="on-true">   <!--周日至周四，早上8点-晚上9点59分-->
        <action application="transfer" data="1105 XML default"/>
    </condition>

    <condition> <!--这是一个捕获所有情况的条件，将呼叫转接到语音信箱。 -->
        <action application="voicemail" data="default ${domain} 1105"/>
    </condition>
</extension>
```

在这个例子中，我们使用break=never参数，无论第一个条件是true还是false，都会使第一个条件“穿透”到下一个条件。这对于设置扩展处理中的某些标志非常有用。此例子中，如果目标号码以1开头，设置变量begins_with_one。

```xml
<extension name="break-demo">
 <!-- 因为设置了 break=never，所以即使目标号码不以1开头，
      我们也会跳过该动作并继续执行 -->
 <condition field="destination_number" expression="^1(\d+)$" break="never">
   <action application="set" data="begins_with_one=true"/>
 </condition>

 <condition field="destination_number" expression="^(\d+)$">
    ...其他可能查询 begins_with_one 的动作...
 </condition>
</extension>
```

##### Asterisk Patterns

除了 PCRE，FreeSWITCH 还支持 Asterisk [Patterns](http://www.voip-info.org/wiki/view/Asterisk+Dialplan+Patterns)，任何以下划线 (\_) 开头的表达式都会使用 Asterisk 模式匹配。请注意，有些模式可能需要转义，比如 "\*"

参见[Mod\_dialplan\_asterisk](https://wiki.freeswitch.org/wiki/Mod%5Fdialplan%5Fasterisk "Mod dialplan asterisk")

```xml
 <extension name="_NXXXXXXXXX_asterisk">
    <condition field="destination_number" expression="_(NXXXXXXXXX)">
      <action application="bridge" data="sofia/internal/$1@example.com"/>
    </condition>
  </extension>

  <extension name="_*XX_with_escaping">
    <condition field="destination_number" expression="_(\*XX)(.)">
      <action application="log" data="ERR captured $1 ~~~ $2"/>
        <action application="answer"/>
        <action application="playback" data="tone_stream://path=${base_dir}/conf/tetris.ttml;loops=10"/>
      </condition>
  </extension>
```

#### 变量

条件语句可以与通道变量或内置变量数组进行匹配。

##### 内置变量

以下变量，称为'呼叫方配置文件字段'，可以直接从条件语句中访问：

* **context** 为什么可以将上下文用作字段？请举例说明一下用途。
* **rdnis** 转接号码，被呼叫方最后接听的号码。
* **destination\_number** 被呼叫号码，这通电话试图联系的号码（在给定的上下文中）。
* **dialplan** 用于的拨号计划模块的名称，该名称由每个拨号计划模块提供。示例：XML
* **caller\_id\_name** 呼叫者姓名（由呼叫我们的用户代理提供）。
* **caller\_id\_number** 打电话的一方（呼叫者）的号码--可以被隐藏。
* **ani** 自动号码识别，呼叫方（呼叫者）的号码 - 无法隐藏。
* **aniii** 拨打电话设备的类型[ANI2](http://www.voip-info.org/wiki/view/ANI2)
* **uuid** 当前通话的唯一标识符？（类似于GUID）
* **source** 接收呼叫的FreeSWITCH模块的名称（例如：PortAudio）。
* **chan\_name** 当前通道的名称（示例：PortAudio/1234）。请举例说明何时可以使用此字段。
* **network\_addr** VoIP呼叫的信令源的IP地址。
* **year** 日历年份，0-9999
* **yday** 一年中的第几天，1-366
* **mon** 月份，1-12（Jan = 1, 等等）
* **mday** 月份中的第几天，1-31
* **week** 一年中的第几周，1-53
* **mweek** 一个月中的第几周，1-6
* **wday** 一周中的第几天，1-7（星期日 = 1，星期一 = 2，等等）或"sun"，"mon"，"tue"等等。
* **hour** 小时，0-23
* **minute** 分钟（小时的分钟数），0-59
* **minute-of-day** 一天中的分钟数，（1-1440）（午夜 = 1, 早上1点 = 60, 中午 = 720, 等等）
* **time-of-day** 时间范围格式化：hh:mm\[:ss\]-hh:mm\[:ss\]（可选秒）示例："08:00-17:00"
* **date-time** 日期/时间范围格式化：YYYY-MM-DD hh:mm\[:ss\]\~YYYY-MM-DD hh:mm\[:ss\]（可选秒，注意两个日期之间的波浪线）示例：2010-10-01 00:00:01\~2010-10-15 23:59:59

举个例子：

```xml
<condition field="network_addr" expression="^192\.168\.1\.1$"/>  <!-- 网络地址=192.168.1.1 -->
<condition mon="2">   <!-- 月份=二月 -->
```

##### 主叫者配置字段 vs. 通道变量

有一件可能令人困惑的事情是[主叫者配置字段](https://wiki.freeswitch.org/wiki/Caller%5Fprofile%5Ffield "Caller profile field")（内置变量）和通道变量的区别。

要访问主叫者配置字段，可以使用以下方式：

```xml
<condition field="destination_number" attributes...>
```

而要访问通道变量，可以使用以下方式：

```xml
<condition field="${sip_has_crypto}" attributes...>
```

请注意**${variable\_name}**的语法。通道变量也可以在动作语句中使用。

此外，在条件语句内部可以调用API函数来提供动态数据。

例如，您可以使用**cond** API：

```xml
<condition field="${cond(${my_var} > 12 ? YES : NO)}" expression="^YES$">
    <action application="log" data="INFO ${my_var} is indeed greater than 12"/>
</condition>
```

这个例子测试了${my\_var}。如果它大于12，则返回"YES"。否则返回"NO"。条件语句测试结果是否为"YES"，并将结果消息记录到FreeSWITCH日志中。

##### 变量的可用性

Asterisk用户请注意！

XML拨号计划具有基于变量和表达式的条件测试的功能；然而，必须理解一些变量可能在第一次转移或执行执行_extension之前不可用（请参见下面的解决方法）。

###### 为什么

实质上，XML拨号计划用于呼叫路由，而不是用于复杂或广泛的条件测试和评估。这就是为什么FreeSWITCH提供了Lua，JavaScript，Perl，Python和其他API，因为它们是比构思复杂的XML解决方案更好的选择，更不用说一些复杂而晦涩的首字母缩写（如"AEL"）了。

这可能会让原来使用Asterisk的用户感到困惑，因为诸如&lt;action application="info"/>之类的info应用程序实际上会显示变量，好像它们可以用于条件测试，而事实上可能并不是这样。

这是因为FreeSWITCH将**搜索**和**执行**分为两个独立的步骤。首先，根据条件、操作和反操作，收集所有需要执行的应用程序。其次，执行这些应用程序的顺序。这意味着由执行的应用程序设置的通道变量在搜索时不会对条件可用。

这就是为什么即使在&lt;action application="info"/>中显示了变量及其值，您可能会发现XML条件失败的原因。

###### 解决方法

解决此问题的方法是在Lua、JavaScript或其他拨号计划脚本语言中实现绝大部分拨号计划逻辑，或者执行一个扩展，使您希望对其进行条件评估的变量在XML拨号计划条件的解析中可用。

自从svn rev [14906](http://fisheye.freeswitch.org/changelog/freeswitch.git/?cs=f21b4a2137410550b4ba9ee493ec27a555b53e90)以来，某些应用程序可以在**[内联](https://wiki.freeswitch.org/wiki/Dialplan%5FXML#Inline%5FActions "Dialplan XML")**中运行。这意味着它们在呼叫流程中被执行，这样这些应用程序设置的通道变量**将**在呼叫流程的后续条件中可用。

#### 动作和反动作

到目前为止，我们已经看到了包含条件以及当条件匹配时运行的动作的示例拨号计划条目。

您还可以指定在不满足分机条件时运行的“反动作”。

在这个例子中，将${my_var}的值与12进行比较，并根据结果记录一条消息。

```xml
<condition field="${cond(${my_var} > 12 ? YES : NO)}" expression="^YES$">
    <action application="log" data="INFO ${my_var} is indeed greater than 12"/>
    <anti-action application="log" data="INFO ${my_var} is not greater than 12"/>
  </condition>
```

##### 可用动作

请参见[API参考](https://wiki.freeswitch.org/wiki/Modules#Applications "Modules")和[Dialplan函数](https://wiki.freeswitch.org/wiki/Dialplan%5FFunctions "Dialplan Functions")

##### 内联动作

您可以在动作上设置一个额外的属性**inline="true"**，以便在拨号计划的[呼叫流程阶段](https://wiki.freeswitch.org/wiki/Dialplan%5FXML#Clarification "Dialplan XML")中执行它：

```xml
<action inline="true" application="set" data="some_var=some_val"/>
```

这使得在后续的分机中可以设置条件，该条件匹配**${some_var}**字段。

请注意，仅可以以内联方式运行那些快速获取或设置某些变量并且不访问或修改当前会话状态的应用程序。

可以以内联方式运行的应用程序包括：

* [check\_acl](https://wiki.freeswitch.org/wiki/Acl#check%5Facl "Acl")
* [eval](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Feval "Misc. Dialplan Tools eval")
* [event](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Fevent "Misc. Dialplan Tools event")
* [export](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Fexport "Misc. Dialplan Tools export")
* [log](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Flog "Misc. Dialplan Tools log")
* [presence](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Fpresence "Misc. Dialplan Tools presence")
* [set](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Fset "Misc. Dialplan Tools set")
* [set\_global](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Fset%5Fglobal "Misc. Dialplan Tools set global")
* [set\_profile\_var](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Fset%5Fprofile%5Fvar "Misc. Dialplan Tools set profile var")
* [set\_user](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Fset%5Fuser "Misc. Dialplan Tools set user")
* [unset](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Funset "Misc. Dialplan Tools unset")
* [verbose\_events](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Fverbose%5Fevents "Misc. Dialplan Tools verbose events")
* [cidlookup](https://wiki.freeswitch.org/wiki/Mod%5Fcidlookup#Dialplan%5FApplication "Mod cidlookup")
* [curl](https://wiki.freeswitch.org/wiki/Mod%5Fcurl#Dialplan%5FApplication "Mod curl")
* [easyroute](https://wiki.freeswitch.org/wiki/Mod%5Feasyroute#Dialplan "Mod easyroute")
* [enum](https://wiki.freeswitch.org/wiki/Mod%5Fenum#Application%5F-%5FExample%5F1%5F.28Basic%5FUsage.29 "Mod enum")
* [lcr](https://wiki.freeswitch.org/wiki/Mod%5Flcr#Dialplan "Mod lcr")
* [nibblebill](https://wiki.freeswitch.org/wiki/Mod%5Fnibblebill#Application%5F.2F%5FCLI%5F.2F%5FAPI%5FCommands "Mod nibblebill")
* [odbc\_query](https://wiki.freeswitch.org/wiki/Mod%5Fodbc%5Fquery "Mod odbc query")

另外要记住，内嵌执行的应用程序不会出现在通话详单记录中，就像通常运行的应用程序一样显示。

#### 完整的语法

```xml
<!-- 对于枚举属性，列表中的第一个值是默认值 -->
<extension name="unique_extension_name" continue="[false|true]">
  <condition field="[field_name|${variable_name}|${api_func(api_args ${var_name})}]" expression="regular expression"
      break="[on-false|on-true|always|never]" require-nested="[true|false]">
    <condition ...><!-- 条件可以嵌套 -->
      ...
    </condition>
    <action application="app name" data="app arg"/>
    <anti-action application="app name" data="app arg"/>
  </condition>

  <!-- 可以跟随多个condition标签，应用相同的规则 -->
</extension>
```

#### 简短摘要

版本1.2.22的完整拨号计划算法：

* 如果条件计算为true并且continue="false"（默认值），则扩展呼叫停止在第一个条件为true的扩展处。
* 如果上一个检查的条件为true，则条件计算为true。
* 条件的检查是深度优先的，直到：
  * break="on-false"并且条件为false，
  * 或者break="on-true"并且条件为true，
  * 或者break="always"。
* 如果表达式匹配，并且没有嵌套条件，或者require-nested="false"，或者嵌套条件计算为true，那么条件为true。
* 如果条件为true，则收集其&lt;action>以供执行；否则，收集其&lt;anti-action>以供执行。
* 如果require-nested="true"（默认值）并且嵌套条件计算为false，则不会收集&lt;anti-action>。（这是有意为之吗？）

### 其他拨号计划的智慧经验

拨号计划在呼叫到达呼叫计划解析器处于“ROUTING”状态时解析一次。通过对XML文件进行一次遍历，将根据解析的&lt;action>或&lt;anti-action>标签安装完整的指令列表到通道中。

习惯于Asterisk的人可能期望通过执行解析应用程序来按照拨号计划进行呼叫，从而使得从一个操作中获取的数据影响下一个操作。但这并不是真的，唯一的例外是${api func(api arg ${var\_name})}字段，其中的可插拔的模块API调用可以在解析进行时执行。这用于实时获取日期、时间或其他快速可访问的信息，**不应当**被滥用。

#### 自动搜索

您可以打开[auto\_hunt](https://wiki.freeswitch.org/wiki/Variable%5Fauto%5Fhunt "Variable auto hunt")，如果分机名称与被拨号码完全匹配，FreeSWITCH将跳转到此扩展来开始搜索。但实际上，它可能匹配或不匹配条件。

#### 通过网关拨号

"gateway"在mod\_sofia中被视为关键词，它表示呼叫将通过配置的网关进行。这对于sofia/profilename/extension@ip-address模式是一个例外。

例如，如果一个名为"gw"的网关，要将呼叫发送到gw的分机100，桥接字符串为：

```xml
<extension name="testing">
  <condition field="destination_number" expression="^(100)$">
    <action application="bridge" data="sofia/gateway/gw/$1"/>
  </condition>
</extension>
```

"destination\_number"是FreeSWITCH的变量，不应该改变。

### 示例

如果您计划将您的分机包含在一个单独的.XML文件中：

* 如果您不需要，请禁用或更改枚举扩展
* 添加&lt;include>标签，并使用&lt;/include>关闭它

#### 示例 1：条件匹配

在下面的示例中，只有在调用端点的IP地址为192.168.1.1时，才会选择特定的扩展。在第二个条件中，拨号号码被提取到变量$1中，并被放入桥接应用程序的数据中，以便拨出到IP地址192.168.2.2。

```xml
<extension name="Test1">
  <condition field="network_addr" expression="^192\.168\.1\.1$"/>
  <condition field="destination_number" expression="^(\d+)$">
    <action application="bridge" data="sofia/profilename/$1@192.168.2.2"/>
  </condition>
</extension>
```

注意，第一个条件字段以/终止！包含行动/反行动的最后一个条件字段应终止于常规的&lt;/condition>标签。另请注意，上述示例与下面的示例不同：

```xml
<extension name="Test1Wrong">
  <condition field="destination_number" expression="^(\d+)$"/>
  <condition field="network_addr" expression="^192\.168\.1\.1$">
    <action application="bridge" data="sofia/profilename/$1@192.168.2.2"/>
  </condition>
</extension>
```

Test1Wrong示例无法正确路由呼叫，因为变量$1将没有任何值，因为目标号码在不同的条件字段中匹配。

您还可以通过在第一个条件中设置一个变量，并在第二个条件的行动中使用该变量来解决Test1Wrong示例。

```xml
<extension name="Test1_2">
  <condition field="destination_number" expression="^(\d+)$">
    <action application="set" data="dialed_number=$1"/>
  </condition>
  <condition field="network_addr" expression="^192\.168\.1\.1$">
    <action application="bridge" data="sofia/profilename/${dialed_number}@192.168.2.2"/>
  </condition>
</extension>
```

请注意，您不能在扩展内部设置的变量用于进一步的条件/匹配，因为在调用操作时才评估扩展。

如果您需要根据扩展内设置的变量执行不同的操作，则需要使用 [execute\_extension](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Fexecute%5Fextension "Misc. Dialplan Tools execute extension") 或 [transfer](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Ftransfer "Misc. Dialplan Tools transfer") 来设置变量。

#### 示例2：匹配多个条件（AND）

在这个示例中，我们需要同时匹配以前缀 1 开头的被叫号码，并且匹配传入的 IP 地址。

```xml
<extension name="Test2">
  <condition field="network_addr" expression="^192\.168\.1\.1$"/>
  <condition field="destination_number" expression="^1(\d+)$">
    <action application="bridge" data="sofia/profilename/$0@192.168.2.2"/>
  </condition>
</extension>
```

在这里，虽然我们匹配了规则 1(\d+)$，但我们没有使用变量 $1，它只包含去掉前导1的其余拨号号码部分，我们使用了变量 $0，它包含了原始目标号码。

#### 示例3：去除前导数字

在这个例子中，我们需要匹配以00开头的被呼叫号码，但我们还需要去除前导数字。假设FreeSWITCH™接收到号码00123456789，并且我们需要去除前导的00数字，我们可以使用下面的扩展代码：

```xml
<extension name="Test3.1">
  <condition field="destination_number" expression="^00(\d+)$">
    <action application="bridge" data="sofia/profilename/$1@192.168.2.2"/>
  </condition>
</extension>
```

另一方面，如果你预期会接收到非数字字符，或者想匹配更多类型的字符，可以使用".+"代替"\\d+"，因为\\d+只匹配数字字符，而.＋将匹配当前位置到字符串末尾的所有字符：

```xml
<extension name="Test3.2">
  <condition field="destination_number" expression="^00(.+)$">
    <action application="bridge" data="sofia/profilename/$1@192.168.2.2"/>
  </condition>
</extension>
```

请注意，正则表达式中包含(.*)或(.+)的情况需要小心。最好不要使用捕获所有表达式，因为你不能相信发送者的信息。在几乎所有的拨号计划中，捕获组应该是数字，所以请使用\d。

#### 示例4：添加前缀

在这个例子中，我们需要像上面一样去除前导数字，但我们还需要在被呼叫号码之前加上一个新的前缀。假设FreeSWITCH™接收到号码00123456789，并且我们需要用011替换00，我们可以使用下面的扩展代码：

```xml
<extension name="Test4">
  <condition field="destination_number" expression="^00(\d+)$">
    <action application="bridge" data="sofia/profilename/011$1@x.x.x.x"/>
  </condition>
</extension>
```

#### 示例5：SIP配置文件（使用不同的配置拨号）

在这个示例中，我们将演示在使用支持配置文件的FreeSWITCH端点时如何使用配置文件，比如[mod_sofia](https://wiki.freeswitch.org/wiki/Mod%5Fsofia "Mod sofia")。假设我们想要为不同的IP地址发送通话时使用不同的通话设置（编解码器，DTMF模式等），我们可以创建不同的配置文件。例如，在sofia.conf的配置中，我们可以看到一个名为"test"的示例配置文件，我们将其改名为profile1，并为此示例添加一个profile2进行比较：

```xml
<profile name="profile1">
  <param name="debug" value="1"/>
  <param name="rfc2833-pt" value="101"/>
  <param name="sip-port" value="5060"/>
  <param name="dialplan" value="XML"/>
  <param name="dtmf-duration" value="100"/>
  <param name="codec-prefs" value="PCMU@20i"/>
  <param name="codec-ms" value="20"/>
  <param name="use-rtp-timer" value="true"/>
</profile>
<profile name="profile2">
  <param name="debug" value="1"/>
  <param name="rfc2833-pt" value="101"/>
  <param name="sip-port" value="5070"/>
  <param name="dialplan" value="XML"/>
  <param name="dtmf-duration" value="100"/>
  <param name="codec-prefs" value="PCMA@20i"/>
  <param name="codec-ms" value="20"/>
  <param name="use-rtp-timer" value="true"/>
</profile>
```

这两个配置文件之间的区别在于编解码器。第一个使用G.711 μ律编解码器，而第二个使用G.711 A律编解码器。

继续上面的示例，我们有：

```xml
<extension name="Test5ulaw">
  <condition field="network_addr" expression="^192\.168\.1\.1$"/>
  <condition field="destination_number" expression="^1(\d+)$">
    <action application="bridge" data="sofia/profile1/$0@192.168.2.2"/>
  </condition>
</extension>
```

以使用G.711 u编解码器发送通话和...

```xml
<extension name="Test5alaw">
  <condition field="network_addr" expression="^192\.168\.1\.1$"/>
  <condition field="destination_number" expression="^1(\d+)$">
    <action application="bridge" data="sofia/profile2/$0@192.168.2.2"/>
  </condition>
</extension>
```

#### 示例6：呼叫已注册用户

这个例子展示了如何桥接到已在FreeSWITCH服务器上注册的设备。在这个例子中，我们假设您已经设置了一个名为“local_profile”的sofia配置文件，并且您的电话是注册到域名为example.com的服务器。请注意，数据字符串中的“@”被替换为“%”。

```xml
<extension name="internal">
  <condition field="source" expression="mod_sofia" />
  <condition field="destination_number" expression="^(4\d+)">
    <action application="bridge" data="sofia/local_profile/$0%example.com" />
  </condition>
</extension>
```

#### 示例7：动作失败时的故障转移

以下示例展示了如果第一个动作失败时如何调用另一个动作。

如果第一个动作成功，通话将被桥接到[1111@example1.company.com](mailto:1111@example1.company.com)，并将一直存在，直到其中一方挂断电话。在此之后，由于呼叫方的通道已关闭，将不会进行其他处理。（即[1111@example2.company.com](mailto:1111@example2.company.com) 不会被调用）

如果对[1111@example1.company.com](mailto:1111@example1.company.com)的初始呼叫**不**成功，通道将保持打开，并调用第二个动作。

```xml
<extension name="internal">
  <condition field="destination_number" expression="^1111">
    <action application="set" data="hangup_after_bridge=true"/>
    <action application="bridge" data="sofia/local_profile/1111@example1.company.com" />
    <action application="bridge" data="sofia/local_profile/1111@example2.company.com" />
  </condition>
</extension>
```

如果你有多个动作，并且第一个动作的应用程序会挂断通道，则不会调用第二个动作。
如果第一个动作不会挂断通道，则会调用第二个动作。

#### 示例8：检查用户是否已通过身份验证

以下示例要求呼叫者在通过之前进行身份验证。这个示例是从邮件列表中摘取的。

```xml
<extension name="9191">
  <condition field="destination_number" expression="^9191$"/>
  <condition field="${sip_authorized}" expression="true">
    <anti-action application="reject" data="407"/>
  </condition>

  <condition>
    <action application="playback" data="/tmp/itworked.wav"/>
  </condition>
</extension>
```

#### 示例9：将DID路由至分机

要将呼入到某个特定DID的呼叫路由到固定分机1001，可以参考以下示例（摘自邮件列表）（其中XXXxxxxxxx是你的呼入DID的电话号码）。

在public.xml中：

```xml
<extension name="test_did">
  <condition field="destination_number" expression="^(XXXxxxxxxx)$">
    <action application="transfer" data="$1 XML default"/>
  </condition>
</extension>
```

然后在default.xml的默认上下文中添加类似以下内容：

```xml
   <extension name="本地扩展">
     <condition field="destination_number" expression="^(XXXxxxxxxx)$">
       <action application="set" data="dialed_ext=$1"/>
     </condition>
     <condition field="destination_number" expression="^${caller_id_number}$">
       <action application="set" data="voicemail_authorized=${sip_authorized}"/>
       <action application="answer"/>
       <action application="sleep" data="1000"/>
       <action application="voicemail" data="check default $${domain} ${dialed_ext}"/>
       <anti-action application="ring_ready"/>
       <anti-action application="set" data="call_timeout=10"/>
       <anti-action application="set" data="hangup_after_bridge=true"/>
       <anti-action application="set" data="continue_on_fail=true"/>
       <anti-action application="bridge" data="USER/1001@$${domain}"/>
       <anti-action application="answer"/>
       <anti-action application="sleep" data="1000"/>
       <anti-action application="voicemail" data="default $${domain} ${dialed_ext}"/>
     </condition>
   </extension>
```

（"bridge" 行中的 1001 是我们要响铃的分机号码）

请注意，来自“public”的电话进入公共环境，在那里它们需要被转移到另一个更友好的环境进行处理，例如默认环境。这就是为什么要将条目添加到 public 并且 'data="$1 XML PFC"' 表示将被叫号码 $1 通过 XML 呼叫计划转移到 PFC 环境。在默认环境中才能实际响铃。

$${domain} 是一个变量，它会自动填写您的域名（很可能是您的 IP）和来电号码。请保持原样。

#### 示例 10：将呼叫路由到具有自定义呼叫者 ID 的网关扩展

在这个示例中，我们演示了以10位数字从分机1000发起呼叫，然后将其路由到[asterlink.com](http://asterlink.com)网关。这个例子展示了如何为特定的分机进行路由，并允许对该分机进行自定义呼叫者ID。

```xml
   <extension name="asterlink.com">
     <condition field="caller_id_number" expression="^1000$"/>
     <condition field="destination_number" expression="^(\d{10})$">        
         <action application="set" data="effective_caller_id_number=8001231234"/>
         <action application="set" data="effective_caller_id_name=800号码"/>
         <action application="bridge" data="sofia/gateway/asterlink.com/1208$1"/>
     </condition>
   </extension>
```

#### 示例11：基于号码前缀进行路由

在这个示例中，我们演示了根据NPANXX将呼叫路由到不同的目的地。还演示了如何用与目的地发送给FreeSWITCH不同的故障消息来回应呼叫方。

```xml
<extension>
  <condition field="network_addr" expression="^(66\.123\.321\.231|70\.221\.221\.221)$" break="on-false"/>
  <condition field="destination_number" expression="^\d+$" break="never">
  <action application="set" data="continue_on_fail=NORMAL_TEMPORARY_FAILURE,TIMEOUT,NO_ROUTE_DESTINATION"/>
  <action application="set" data="bypass_media=true"/>
  <action application="set" data="accountcode=myaccount"/>
  </condition>
  <condition field="destination_number" expression="^(1813\d+|1863\d+|1727\d+|1941\d+|404\d+)$" break="never">
  <action application="bridge" data="sofia/outbound_profile/${sip_to_user}@switch1.mydomain.com"/>
  <action application="info"/>
  <action application="respond" data="503"/>
  <action application="hangup"/>
  </condition>
  <condition field="destination_number" expression="^(1404\d+|1678\d+|1770\d+)$">
  <action application="bridge" data="sofia/outbound_profile/${sip_to_user}@switch2.mydomain.com"/>
  <action application="info"/>
  <action application="respond" data="503"/>
  <action application="hangup"/>
  <anti-action application="respond" data="503"/>
  <anti-action application="hangup"/>
  </condition>
</extension>
```

#### 示例 12：处理未匹配到目标的呼叫

在这个示例中，我们演示了如何捕获无效的分机或目标。

* 您需要将此分机添加到跳转计划的底部，以便可以包含 ENUM。
* 请参阅 [mod\_enum](https://wiki.freeswitch.org/wiki/Mod%5Fenum "Mod enum")。

```xml
<extension name="catchall">
  <condition field="destination_number" expression=".*" continue="true">
   <action application="playback" data="misc/invalid_extension.wav"/>
  </condition>
</extension>
```

#### 示例 13：来电筛查

在这个例子中，我们要求呼叫者提供一个名字，然后连接到被呼叫方并宣布该名字。被呼叫方可以按1接听电话，或挂断。如果被呼叫方挂断，呼叫者将会被连接到语音信箱。

```xml
<extension name="screen">
   <condition field="destination_number" expression="^(\d{4})$">
     <action application="set" data="call_screen_filename=/tmp/${caller_id_number}-name.wav"/>
     <action application="set" data="hangup_after_bridge=true" />
     <action application="answer"/>
     <action application="sleep" data="1000"/>
     <action application="phrase" data="voicemail_record_name"/>
     <action application="playback" data="tone_stream://%(500, 0, 640)"/>
     <action application="set" data="playback_terminators=#*0123456789"/>
     <action application="record" data="${call_screen_filename} 7 200 2"/>
     <action application="set" data="group_confirm_key=1"/>
     <action application="set" data="fail_on_single_reject=true"/>
     <action application="set" data="group_confirm_file=phrase:screen_confirm:${call_screen_filename}"/>
     <action application="set" data="continue_on_fail=true"/>
     <action application="bridge" data="user/$1"/>
     <action application="voicemail" data="default $${domain} $1"/>
     <action application="hangup"/>
   </condition>
 </extension>
```

#### 示例 14: 媒体录制

该扩展用于播放/录制音频(wav)格式的媒体，以供录制/回放使用。

* 感谢 rupa 的帮助。

```xml
<extension name="receive_fax">
    <condition field="destination_number" expression="^fax$">
        <action application="answer"/>
        <action application="set" data="fax_enable_t38=true"/>
        <action application="set" data="fax_file=/tmp/incoming_fax.pdf"/>
        <action application="rxfax" data=""/>
    </condition>
</extension>
```

#### Example 17: 从传入的 DID 接收传真

这个示例演示了如何从传入的 DID 接收传真。

```xml
<extension name="receive_fax">
    <condition field="destination_number" expression="^fax$">
        <action application="answer"/>
        <action application="set" data="fax_enable_t38=true"/>
        <action application="set" data="fax_file=/tmp/incoming_fax.pdf"/>
        <action application="rxfax" data=""/>
    </condition>
</extension>
```

要使用freeswitch / conf / dialplan / default.xml中的预定义fax_receive扩展来处理呼入呼叫，将其放在freeswitch / conf / dialplan / public / fax.xml中：

```xml
<include>
  <extension name="incoming-fax">
    <condition field="destination_number" expression="^$${local_fax_number}$">
      <action application="set" data="domain_name=$${domain}"/>
      <action application="transfer" data="9178 XML default"/>
    </condition>
  </extension>
</include>
```

然后在freeswitch / conf / vars.xml中，将您的传真号码设置为1234或其他任何号码：

```xml
<X-PRE-PROCESS cmd="set" data="local_fax_number=1234"/>
```

#### 示例 18：在BRI呼入呼叫上为effective_caller_id_number添加国际呼叫前缀

在使用FreeTDM和BRI线路的zaphfc时，接收到的呼入呼叫中将不包含呼叫者的国际呼叫前缀。此扩展将其添加到effective_caller_id_number。

国际呼叫前缀的说明可以参考这里：<http://en.wikipedia.org/wiki/International%5Fprefix>。

在德国，国际呼叫前缀被称为“Verkehrsausscheidungsziffer”(VAZ)，请参见<http://de.wikipedia.org/wiki/Verkehrsausscheidungsziffer>。

国际呼叫前缀永远不会传输。可以通过查看ToN信息来预测它。

```xml
<extension name="Add-VAZ" continue="true">
<!--
在BRI呼入呼叫中，Verkehrsausscheidungsziffer (VAZ)被丢弃。
此扩展再次将其添加到caller_id_number中。
TODO: 添加对国际号码的支持
-->
	<condition field="source" expression="^mod_freetdm$">
	<action application="set" data="effective_caller_id_number=0${caller_id_number}"/>
	</condition>
</extension>
```

#### 示例19：DISA

能够拨入FS盒子并获得拨号音，就像在Asterisk的DISA()函数中一样。

在FS/conf/dialplan/public/\*.xml文件中

```xml
<!-- -->
<!-- -->
<!-- -->
<!-- 注意!!! 在此处是TRANSFER。可能存在安全风险。注意!!! -->
<!-- -->
<!-- -->
<!-- -->
<extension name="incoming-bri-wor">
	<condition field="destination_number" expression="^(disa_target)$">
		<action application="answer"/>
		<action application="start_dtmf"/>
		<action application="play_and_get_digits" data="2 5 3 37000 #
			$${base_dir}/sounds/en/us/callie/ivr/8000/ivr-please_enter_pin_followed_by_pound.wav
			$${base_dir}/sounds/en/us/callie/ivr/8000/ivr-pin_or_extension_is-invalid.wav
			digits ^$${DISA_PASSWORD}$"/>
		<action application="transfer" data="$1 XML default"/>
	</condition>
</extension>
```

在FS/conf/dialplan/default/03\_DISA.xml文件中

```xml
<!--
	DISA - 允许拨入盒子并获得类似新线路的拨号音
-->

<include>
<extension name="DISA for FS">
	<condition field="destination_number" expression="^(disa_target)$">
		<action application="answer"/>
		<action application="read" data="2 15 'tone_stream://%(10000,0,350,440)' digits 30000 #"/>
		<action application="execute_extension" data="${digits}"/>
                <action application="transfer" data="disa_target XML default"/>
	</condition>
</extension>
</include>
```

请将"disa_target"替换为您的分机号码。

您可以使用此技术从公网电话/移动电话拨入您的盒子，并获得拨号音，以执行任何操作。

#### 示例20：修复无效的呼叫者ID

如果你遇到B路不喜欢无效的呼叫者ID的问题；例如，你有一个带有From:头部为From: &lt;sip:Unavailable@Unavailable.invalid:5060>的INVITE消息。
你可以强制将无效的号码替换为一个固定的呼叫者ID号码。下面的示例检查有效的NANPA CLID：

```xml
   <extension name="invalid_caller_id_fix" continue="true">
     <condition field="caller_id_number" expression="^1?([2-9]\d{2}[2-9]\d{6})$">
       <action application="set" data="effective_caller_id_number=$1"/>
       <anti-action application="set" data="effective_caller_id_number=2135551212"/>
     </condition>
   </extension>
```

示例21：阻止出站呼叫者ID

如果要通过拨号\*67跟随拨号号码来阻止拨打方的呼叫者ID，您可以执行以下操作：

```xml
    <extension name="block_caller_id">
      <condition field="destination_number" expression="^\*67(\d+)$">
	<action application="privacy" data="full"/>
	<action application="set" data="sip_h_Privacy=id"/>
	<action application="set" data="privacy=yes"/>
	<action application="transfer" data="$1 XML default"/>
      </condition>
    </extension>
```

示例22：在执行数据库查找时播放音乐

如果在执行需要很长时间的数据查找时想要播放音乐，可以通过使拨号计划使用FSAPI通过变量扩展调用脚本的luarun来完成。
这样，将启动一个新线程来执行Lua脚本。

```xml
sofia/my_profile/alias/1234 
```

```xml
{originate_codec_string=XXXX}sofia/my_profile/1234@192.168.0.1 &bridge($${sofia_contact(${dialed_user}@${dialed_domain})})
```

In this example, XXXX represents the codec to be used. The originate_codec_string variable is used to specify the codec for the originate leg, while the bridge function is used to bridge the call to the specified user and domain.

```xml
originate {absolute_codec_string=XXXX}sofia/default/foo@bar.com bridge:portaudio/auto_answer inline
```

#### 修改 SIP 联系人

FreeSWITCH 在内部 SIP 联系人上通常使用 mod\_sofia@ip:port。要将其更改为 foo@ip:port，可以使用变量 sip_contact_user：

```xml
{sip_contact_user=foo}sofia/my_profile/1234@192.168.0.1;transport=tcp
```

#### 使用自定义 SIP URI

FreeSWITCH 允许您根据需要指定自定义 URI。例如，您可能需要与仅在特定格式下格式化的设备进行互操作。关键是在拨号字符串中使用 "sip:" 作为 SIP URI 的前缀。例如：

```xml
sofia/my_profile/sip:xxxx;phone-context=cdp.udp@somedomain.com;user=phone
```

上述示例将精确地发送 URI，包括 "sip:" 前缀。

#### 使用命令行测试拨号计划

```xml
originate loopback/<destination number>/<mycontext> hangup inline
```

您还可以根据拨号计划的要求设置变量。请参考以下示例：

```xml
originate {toll_allow=international}loopback/0116628888888/default hangup inline
```

#### 为呼叫转移设置 SIP Diversion 标头

```xml
<action application="export" data="sip_h_Diversion=<sip:2134445555@1.2.3.4>;reason=unavailable"/>
```

### 相关内容

* [Dialplan](https://wiki.freeswitch.org/wiki/Dialplan "Dialplan")
* [Dialplan ARRAYS](https://wiki.freeswitch.org/wiki/Dialplan%5FARRAYS "Dialplan ARRAYS")
* [Freeswitch IVR Originate](https://wiki.freeswitch.org/wiki/Freeswitch%5FIVR%5FOriginate "Freeswitch IVR Originate")
* [Channel Variables](https://wiki.freeswitch.org/wiki/Channel%5FVariables "Channel Variables")
* [Dialplan Recipes](https://wiki.freeswitch.org/wiki/Dialplan%5FRecipes "Dialplan Recipes")
* [Misc.\_Dialplan\_Tools\_bridge](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Fbridge "Misc. Dialplan Tools bridge")