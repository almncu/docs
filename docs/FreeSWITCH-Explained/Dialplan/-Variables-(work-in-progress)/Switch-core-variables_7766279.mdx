# 切换核心变量

## 关于

这是FreeSWITCH核心中定义的通道变量列表。

点击这里展开目录

* 1 [时间戳变量](#timestamp-variables)
* 2 [累计计时器](#accumulated-timers)
* 3 [absolute\_codec\_string](#absolute_codec_string)
* 4 [api\_after\_bridge](#api_after_bridge)
* 5 [api\_hangup\_hook](#api_hangup_hook)
* 6 [api\_on\_answer](#api_on_answer)
* 7 [api\_on\_media](#api_on_media)
* 8 [api\_on\_startup](#api_on_startup)
* 9 [asr\_intercept\_dtmf](#asr_intercept_dtmf)
* 10 [bind\_meta\_key](#bind_meta_key)
* 11 [bridge\_answer\_timeout](#bridge_answer_timeout)
* 12 [bridge\_channel](#bridge_channel)
* 13 [bridge\_early\_media](#bridge_early_media)
* 14 [bridge\_filter\_dtmf](#bridge_filter_dtmf)
* 15 [bridge\_generate\_comfort\_noise](#bridge_generate_comfort_noise)
* 16 [bridge\_hangup\_cause](#bridge_hangup_cause)
* 17 [bridge\_pre\_execute\_aleg\_app](#bridge_pre_execute_aleg_app)
* 18 [bridge\_pre\_execute\_aleg\_data](#bridge_pre_execute_aleg_data)
* 19 [bridge\_pre\_execute\_bleg\_app](#bridge_pre_execute_bleg_app)
* 20 [bridge\_pre\_execute\_bleg\_data](#bridge_pre_execute_bleg_data)
* 21 [bridge\_terminate\_key](#bridge_terminate_key)
* 22 [bridge\_to](#bridge_to)
* 23 [bridge\_uuid](#bridge_uuid)
* 24 [bypass\_media](#bypass_media)
* 25 [bypass\_media\_after\_bridge](#bypass_media_after_bridge)
* 26 [缓存语音句柄](#cache_speech_handles)
* 27 [呼叫超时](#call_timeout)
* 28 [主叫ID](#caller_id)
* 29 [主叫ID名称](#caller_id_name)
* 30 [主叫ID号码](#caller_id_number)
* 31 [通道名称](#channel_name)
* 32 [编解码字符串](#absolute_codec_string)
* 33 [失败后继续](#continue_on_fail)
* 34 [拷贝JSON CDR](#copy_json_cdr)
* 35 [拷贝XML CDR](#copy_xml_cdr)
* 36 [当前应用程序](#current_application)
* 37 [当前应用程序数据](#current_application_data)
* 38 [当前应用程序响应](#current_application_response)
* 39 [默认语言](#default_language)
* 40 [目标号码](#destination_number)
* 41 [拨号的域名](#dialed_domain)
* 42 [拨号的用户](#dialed_user)
* 43 [拨号的数字](#digits_dialed)
* 44 [过滤拨号的数字](#digits_dialed_filter)
* 45 [方向](#direction)
* 46 [禁用应用程序日志](#disable_app_log)
* 47 [禁用RTP保持](#rtp_disable_hold)
* 48 [禁用RTP自动调整](#disable_rtp_auto_adjust)
* 49 [错误时替代挂断](#displace_hangup_on_error)
* 50 [域名](#domain_name)
* 51 [丢弃DTMF](#drop_dtmf)
* 52 [丢弃DTMF屏蔽文件](#drop_dtmf_masking_file)
* 53 [丢弃DTMF屏蔽数字](#drop_dtmf_masking_digits)
* 54 [DTMF类型](#dtmf_type)
* 55 [eavesdrop\_announce\_id, eavesdrop\_announce\_macro](#eavesdrop_announce_id-eavesdrop_announce_macro--)
* 56 [eavesdrop\_group, eavesdrop\_require\_group](#eavesdrop_group-eavesdrop_require_group--)
* 57 [有效主叫ID名称](#effective_caller_id_name)
* 58 [有效主叫ID号码](#effective_caller_id_number)
* 59 [启用文件写入缓冲](#enable_file_write_buffering)
* 60 [启用心跳事件, 设置时触发, 使用调度器](#enable_heartbeat_events-heartbeat_fire_on_set-heartbeat_use_scheduler--)
* 61 [ep\_codec\_prefer\_sdp](#ep_codec_prefer_sdp)
* 62 [ep\_codec\_string](#absolute_codec_string)
* 63 [exec\_after\_bridge\_app, exec\_after\_bridge\_arg](#exec_after_bridge_app-exec_after_bridge_arg--)
* 64 [应答后执行](#execute_on_answer)
* 65 [媒体时执行](#execute_on_media)
* 66 [媒体超时时执行](#execute_on_media_timeout)
* 67 [发起时执行](#execute_on_originate)
* 68 [接听前执行](#execute_on_pre_answer)
* 69 [振铃时执行](#execute_on_ring)
* 70 [导出变量](#export_vars)
* 71 [单个拒绝时失败](#fail_on_single_reject)

## 时间戳变量

以下变量在通道挂断后由FreeSWITCH设置，并包含通道各种状态变化的时间戳。

| 状态变化                | 变量（秒级时间戳）       | 变量（微秒级时间戳）          | 变量（日期和时间）       |
| ----------------------- | ----------------------- | ---------------------------- | ----------------------- |
| 呼叫方配置创建           | profile\_start\_epoch    | profile\_start\_uepoch        | profile\_start\_stamp   |
| 启动                    | start\_epoch            | start\_uepoch                | start\_stamp            |
| 接听                    | answer\_epoch           | answer\_uepoch               | answer\_stamp           |
| 桥接                    | bridge\_epoch           | bridge\_uepoch               | bridge\_stamp           |
| 最后保持                | last\_hold\_epoch       | last\_hold\_uepoch           | hold\_stamp             |
| 复活                    | resurrect\_epoch        | resurrect\_uepoch            | resurrect\_stamp        |
| 进展                    | progress\_epoch         | progress\_uepoch             | progress\_stamp         |
| 媒体进展                | progress\_media\_epoch  | progress\_media\_uepoch      | progress\_media\_stamp  |
| 挂断                    | end\_epoch              | end\_uepoch                  | end\_stamp              |

## 累计计时器

以下变量显示通道挂断后以不同格式呈现的各种与时间相关的信息：

| 值                                                         | 变量（秒）       | 变量（毫秒）            | 变量（微秒）           |
| --------------------------------------------------------- | ------------ | ------------------- | ------------------- |
| 通话持续时间（从通道创建到挂断）                               | duration     | mduration          | uduration          |
| 等待时间（从创建到桥接状态）                                 | waitsec      | waitmsec           | waitusec           |
| 总等待时间                                                   | hold\_accum\_seconds | hold\_accum\_ms    | hold\_accum\_usec  |
| 计费时间（从应答到挂断）                                     | billsec      | billmsec           | billusec           |
| 话单计费时间（从创建到挂断）                                 | flow\_billsec | flow\_billmsec     | flow\_billusec     |
| 等待应答时间（从创建到应答）                                 | answersec    | answermsec         | answerusec         |
| 等待呼叫进程时间（从创建到进程）                             | progresssec  | progressmsec       | progressusec       |
| 等待媒体进程时间（从创建到进程\_媒体）                     | progress\_mediasec | progress\_mediamsec | progress\_mediausec |

## absolute_codec_string

设置要使用的绝对编解码器串（不会附加任何内容）。

**用法：**

```xml
<action application="set" data="absolute_codec_string=PCMU,GSM"/>
<action application="bridge" data="sofia/gateway/myprovider/5551231234"/>
```

**每腿呼叫字符串：**

```xml
<action application="export" data="nolocal:api_on_answer=uuid_broadcast ${uuid} beep.wav both"/>
```

Or,

```xml
<action application="bridge" data="{api_on_answer='uuid_broadcast ${uuid} beep.wav both'}sofia/gateway/provider/5551231234"/> 
```

## api_on_media

当对端发出媒体信号，例如响铃或者183/SDP时，执行一个FreeSWITCH API。

该命令只在尚未接通的通道上执行。使用`export`或者带有`nolocal:`前缀的`export`来确保在b-leg接通时执行。

在下面的第二个使用示例中，我们发起了一个向本地分机的呼叫，我们将等待30秒而不忽略媒体信号。这种情况下我们使用`set`而不是`export`。

**使用方法：**

```xml
<action application="export" data="nolocal:execute_on_media=lua incrInUse.lua ${uuid}"/>
```

## api_on_startup

开启时执行一个api（而不是应用）。

**使用方法：**

```xml
<X-PRE-PROCESS cmd="set" data="api_on_startup=sofia recover"/>
```

## asr_intercept_dtmf

如果设置为true，则会将DTMF输入与自动语音识别一起解释。

## bind_meta_key

选择要与 [mod\_dptools: bind\_meta\_app](../../Modules/mod-dptools/6586418.mdx#about) dialplan应用程序（或使用 `switch_ivr_bind_dtmf_meta_session` 核心函数将应用程序调用绑定到DTMF输入的任何其他应用程序）一起使用的 meta 键。

**使用方法：**

```xml
<action application="set" data="bind_meta_key=#"/>
```

## bridge_answer_timeout

在没有被接通的情况下，容忍早期媒体接入的桥接超时时间（可以在任一侧设置）。当你想要将早期媒体从b-leg传递到a-leg并且仍然使用`${call_timeout}`时，这会非常有用。如果在 `bridge_answer_timeout` 之前没有收到200 OK，则认为桥接失败。

**使用方法：**

```xml
<action application="set" data="bridge_answer_timeout=20"/>
```

## bridge_channel

成功进行桥接后，FreeSWITCH会在两条通话路上设置`bridge_channel`变量，以指示对方通道的通道名称。

## bridge_early_media

默认情况下，此值为false。当设置为true时，桥接操作将使用B端的实时音频作为A端的回铃音。设置`bridge_early_media=true`意味着提前媒体将会被缓冲。

如果您正在使用回环通道执行与发送提前媒体并且接收到的提前媒体音频质量下降的端点的桥接，请考虑将其设置为true。通过设置`bridge_early_media=true`带来更高的资源成本（相比于`bridge_early_media=false`），但可能会改善提前媒体的音质。

**用法:**

```xml
<action application="set" data="bridge_early_media=true"/>
```

## bridge_filter_dtmf

将此变量设置为true将阻止在桥接时从此通道接收到的DTMF信号发送到另一通道。

**用法:**

您可以在应答之前在呼叫计划中设置此变量，或者作为呼叫字符串的一部分进行内联设置。

示例呼叫计划用法:

```xml
<action application="set" data="bridge_filter_dtmf=true" />
```

示例呼叫字符串用法:

```xml
{bridge_filter_dtmf=true}sofia/default/blah@baz.com
```

## bridge_generate_comfort_noise

在桥接会话中接收到间断音频帧（静音抑制）时生成舒适噪音。

当大于0时，此变量将被设置为产生静音的除数。常见的值为400或1400，但您可以尝试其他选择以选择听起来最好的值。

当设置为true时，FreeSWITCH将选择默认的舒适噪音值。

当设置为-1时，FreeSWITCH将传输无舒适噪音的静音。

**用法:**

Leg A希望连续的音频流，但是Leg B正在使用静音抑制：

```xml
<action application="set" data="bridge_generate_comfort_noise=true"/>
<action application="bridge" data="sofia/user/1000"/>
```

Leg A使用静音抑制，但是Leg B希望连续的音频流：

```xml
<action application="bridge" data="{bridge_generate_comfort_noise=true}sofia/user/1000"/>
```

## bridge_hangup_cause

这个值被设置为呼叫中最后一个桥接的B leg的挂断原因。如果您在应用中设置了`continue_on_fail=true`和`hangup_after_bridge=false`，可以检查这个值以了解呼叫的“真实”情况。例如，您可以在桥接之后执行扩展，对`${bridge_hangup_cause}`进行条件检查，看它是否包含`MEDIA_TIMEOUT`，然后重新拨打电话或将其转移到手机上。有关挂断原因的列表，请参见[挂断原因](../../Troubleshooting-Debugging/Hangup-Cause-Code-Table_3964945.mdx#about)。

**用法示例：**

```xml
<action application="log" data="1 B leg挂断原因：${bridge_hangup_cause}"/>
```

## bridge_pre_execute_aleg_app

在对两个通道进行桥接之前，在A leg上要执行的命令或API。

注意：这个命令在呼叫建立完成后但媒体（音频）桥接之前执行。

## bridge_pre_execute_aleg_data

与`bridge_pre_execute_aleg_app`一起使用的参数。

## bridge_pre_execute_bleg_app

在对两个通道进行桥接之前，在B leg上要执行的命令或API。在从事件套接字，CLI或XML-RPC发起呼叫时非常有用。

例如，您可以使用脚本或`mod_http`向Snom电话的IP地址发送HTTP GET请求，以增加铃声音量，这样您就可以进行唤醒呼叫。

也可以用于将DTMF事件绑定到呼叫的B端的应用程序中，以便在转接时保持存活。

注意：此操作在呼叫建立之后但媒体（音频）桥接之前执行。

**用法：**

```xml
<action application="set" data="bridge_pre_execute_bleg_app=bind_meta_app"/>
<action application="set" data="bridge_pre_execute_bleg_data=1 a s att_xfer::sofia/profile/destination"/>
```

## bridge_pre_execute_bleg_data

用于与`bridge_pre_execute_bleg_app`一起使用的参数。

## bridge_terminate_key

允许将按键绑定到桥接，如果DTMF匹配，则终止桥接。

## bridge_to

在启动桥接时，将该变量设置在两个呼叫腿上，以指示另一个腿的通道UUID。

## bridge_uuid

在成功桥接后，FreeSWITCH在两个呼叫腿上设置`bridge_uuid`变量，以指示另一个腿的通道UUID。

## bypass_media

当设置为true时，原始呼叫腿的远端媒体地址将被传递到新呼叫腿的远端，反之亦然，因此信令经过FreeSWITCH，但媒体是点对点的。

**用法：**

```xml
 <action application="set" data="bypass_media=true"/>
```

## bypass_media_after_bridge

在桥接完成后绕过媒体非常有用。

适用于Verto注意事项

bypass\_media\_after\_bridge 在Verto中未实现。

**用法：**

```xml
 <action application="set" data="bypass_media_after_bridge=true"/>
```

对于已经建立的通道并进行稍后绕过非常有用。

```xml
 uuid_setvar <uuid> bypass_media_after_bridge true
 uuid_broadcast <uuid> bridge::<endpoint>
```

## cache_speech_handles

如果设置为true，则TTS引擎句柄将被缓存以便在后续使用中而不是每次使用时重新创建。

## call_timeout

控制在使用`bridge`应用程序时，呼叫B路的振铃时长（以秒为单位）。超时时间设置在A路上，并适用于通道中的任何桥接。

如果您需要设置没有A路的呼叫的超时时间，请使用[originate_timeout](https://wiki.freeswitch.org/wiki/Variable%5Foriginate%5Ftimeout "Variable originate timeout")。

如果您需要设置企业桥接/发起的超时时间，请使用[originate_timeout](https://wiki.freeswitch.org/wiki/Variable%5Foriginate%5Ftimeout "Variable originate timeout")。

如果您需要针对每个路设置超时时间（即每个目的地的不同超时时间），请使用[leg_timeout](https://wiki.freeswitch.org/wiki/Variable%5Fleg%5Ftimeout "Variable leg timeout")变量。

默认值：60

**用法：**

```xml
<action application="set" data="call_timeout=20"/>
```

**注意：**

如果要为group\_call()列表指定呼叫超时时间，请使用以下格式：

```xml
 <action application="bridge" data="{originate_timeout=24}${group_call(sales@$${domain})}"/>
```

请注意，如果您没有使用`{ignore_early_media=true}`，一旦收到早期媒体信号，`call_timeout`将不再适用。

## caller_id

在呼叫挂断后，FreeSWITCH会设置该变量以反映主叫方的呼叫者ID号码或呼叫者姓名和号码的组合。

## caller_id_name

被呼叫方设置的呼叫者id名称，不是一个真正的变量，实际上是只读的。

## caller_id_number

被呼叫方设置的主叫方ID电话号码，不是一个真正的变量，实际上是只读的。从sofia.c来看，优先使用以下值的用户部分：P-Preferred-Identity，P-Asserted-Identity，Remote-Party-ID和From header。

## channel_name

此变量由各种模块设置，并包含一个非唯一描述渠道的字符串。也可以通过`set_name`拨号计划应用程序进行更改。

## codec_string

设置要使用的基本编解码器字符串。

**用法：**

```xml
<action application="set" data="codec_string=PCMU,GSM"/>
```

## continue_on_fail

控制在无法联系到被叫方（忙/离线）时发生的情况。如果为"true"，则继续处理拨号计划。如果为"false"，则拨号计划将停止处理。还可以包含将在失败时继续返回的消息。

**用法：**

```xml
<action application="set" data="continue_on_fail=true"/>
```

或，

```xml
<action application="set" data="continue_on_fail=NORMAL_TEMPORARY_FAILURE,USER_BUSY,NO_ANSWER,NO_ROUTE_DESTINATION"/>
```

或Q.850原因码，

```xml
<action application="set" data="continue_on_fail=3,17,18,27"/>
```

## copy_json_cdr

将B leg的JSON CDR复制到名为`b_leg_cdr`的A leg变量中，作为URL编码字符串。此变量必须在B leg中设置，因此在拨号字符串中使用`{copy_xml_cdr=true}`或使用`export`而不是`set`。

**用法：**

```xml
<action application="bridge" data="{copy_json_cdr=true} user/${dialed_extension}@${domain_name}"/>
```

**另请参阅：**

* [mod\_json\_cdr](../../Modules/mod_json_cdr_4653124.mdx#-output-example-cdrs-)

## copy_xml_cdr

将B leg的XML CDR复制到名为`b_leg_cdr`的A leg变量中，作为URL编码字符串。此变量必须在B leg中设置，因此在拨号字符串中使用`{copy_xml_cdr=true}`或使用`export`而不是`set`。

**用法：**

```xml
<action application="bridge" data="{copy_xml_cdr=true} user/${dialed_extension}@${domain_name}"/>
```

**另请参阅：**

* [mod\_xml\_cdr](../../Modules/mod_xml_cdr_6587377.mdx#faq)

## current_application

当前正在执行的通道上的应用程序的名称。

## current_application_data

当前执行的应用程序的参数。

## current_application_response

上一个执行的应用程序返回的响应字符串。

## default_language

控制当API调用中没有明确指定语言时，Say Phrase引擎将使用的默认语言。这样你就可以通过在调用时只更改一个变量来轻松支持多种语言。

**用法:**

```xml
<action application="set" data="default_language=fr"/>
```

## destination_number

此变量指示呼叫目标字符串。

## dialed_domain

当呼叫定位到目录用户时，此变量由多个命令和应用程序（如`bridge`和`originate`）设置。它包含与用户关联的域名。

## dialed_user

与 `dialed_domain` 类似，`dialed_user` 在呼叫连接到目录用户时包含用户名称。

## digits_dialed

在通道挂断后，此变量包含在通话期间拨号的DTMF数字，如果没有拨号数字，则为“none”。变量`digits_dialed_filter`可以定义一个正则表达式过滤器，以应用于拨号的数字。

## digits_dialed_filter

此变量定义一个正则表达式过滤器，用于在拨号的DTMF数字显示在`digits_dialed`变量之前应用的拨号数字。

## direction

此变量根据呼叫方向设置为“inbound”或“outbound”。

## disable_app_log

默认情况下，每个执行的应用程序都存储在会话对象中，并在呼叫结束时写入XML CDR或JSON CDR。如果将此变量设置为“true”，则禁用此行为。

## rtp_disable_hold

当设置为true时，用户无法将呼叫保持。

## disable_rtp_auto_adjust

如果RTP自动调整的表现与预期不符，请禁用该功能。

它会阻止交换机根据源地址重新编写RTP目标。

当RTP自动调整打开时，FreeSWITCH会将目标RTP地址（端口？）更改为与传入数据包的源匹配，如果对方真的希望在不同的地址（端口？）发送和接收，那么这个功能则不起作用。

## DISPL ACE_HANGUP_ON_ERROR

如果将此通道变量设置为"true"，则会导致在尝试 [uuid\_displace](https://wiki.freeswitch.org/wiki/Mod%5Fcommands#uuid%5Fdisplace "Mod commands") 时出现错误时，呼叫被挂断。 默认值为"false"。

## domain_name

在来自经过身份验证的用户的入站通道中，`domain_name`和`user_name`分别反映了目录中的域名和用户名。

## drop_dtmf

在`answer`之前设置入站通道上的该选项，或者在`bridge`或者`originate`之前设置出站通道上的该选项，以防止DTMF事件被发送到通道。

**用法：**

```xml
<action application="set" data="drop_dtmf=true"/>
<action application="answer"/>
```

或者,

```xml
<action application="export" data="nolocal:drop_dtmf=true"/>
<action application="bridge" data="sofia/internal/100@1.2.3.4"/>
```

或者,

```xml
<action application="bridge" data="{drop_dtmf=true}sofia/internal/100@1.2.3.4"/>
```

## drop_dtmf_masking_file

如果`drop_dtmf`设置为"true"，`drop_dtmf_masking_file`可以指向一个播放字符串，该字符串将在另一条线路上播放，而不是DTMF信号。

## drop_dtmf_masking_digits

如果`drop_dtmf`设置为"true"，`drop_dtmf_masking_digits`可以包含一串数字，这些数字将在另一条线路上的每个DTMF音调的位置上播放。

## dtmf_type

设置DTMF信号在通道中传输的方式。对于嵌入式DTMF，必须在拨号计划中使用[Misc. Dialplan Tools start_dtmf](../../Modules/mod-dptools/6587132.mdx#0-about)。

可接受的值："`rfc2833`"，"`info`"，"`none`"

## eavesdrop_announce_id, eavesdrop_announce_macro

在`eavesdrop`应用程序中，以及其他使用eavesdrop的应用程序（`spy`，`three_way`等），如果在加入通道中定义了变量`eavesdrop_announce_id`，则在第三方加入之前，会在窃听会话中播放公告宏。默认情况下，使用`eavesdrop_announce_id`变量的值作为输入参数播放短语宏`eavesdrop_announce`。通过定义加入通道中的变量`eavesdrop_announce_macro`，可以更改宏的名称。

## eavesdrop_group, eavesdrop_require_group

在`eavesdrop`应用程序中，以及其他使用eavesdrop的应用程序中，如果指定了`eavesdrop_require_group`，则`eavesdrop`只能与将`eavesdrop_group`通道变量设置为相同名称的通道一起使用。

## effective_caller_id_name

设置有效的主叫ID名称。这会自动导出到B单元线路上；然而，在起始字符串中无效。换句话说，在呼叫桥接之前设置这个值，否则使用`origination_caller_id_name`。

**对于Snom 370/820用户：**

如果想要在第B方（本地Snom电话）响铃时尽快显示A方的名称（如果有），必须按照描述设置`origination_caller_id_name`或`effective_caller_id_name`。否则，在B方的显示屏上，在铃声响起并由B方接听电话后，你将看到A方的号码切换为A方的名称。要删除此设置，请将其设置为"\_undef\_"。

**用法：**

```xml
<action application="set" data="ep_codec_prefer_sdp=true"/>
```

Sets whether the endpoint should prefer using the codec from the SDP negotiation. If set to "true", the endpoint will prioritize the codec negotiated in the SDP. If set to "false", the endpoint will prioritize the codec configuration in the endpoint settings.

如果设置为true，B端将优先使用A端提议的编解码器。

## ep_codec_string

`ep_codec_string`包含A端的“终端点”编解码器字符串。此编解码器列表仅包括A端和FreeSWITCH都同意的编解码器。仅当在SIP配置文件上启用了inbound-late-negotiation时，才设置此变量。
注意：当列表中存在多个编解码器时，优先顺序由FreeSWITCH选择，而不是A端。

**用法:**

```xml
<action application="bridge" data="{absolute_codec_string=${ep_codec_string}}sofia/foo/bar@baz"/>
```

## exec_after_bridge_app，exec_after_bridge_arg

在桥接结束后执行一个应用程序命令。应用程序由`exec_after_bridge_app`指定，`exec_after_bridge_arg`指定参数。相比之下，要在桥接建立时执行，请使用**execute_on_answer**。

**用法:**

```xml
<action application="set" data="exec_after_bridge_app=transfer"/>
<action application="set" data="exec_after_bridge_arg=2102"/> 
```

**另请参阅:**

* [exec\_after\_bridge\_arg](https://wiki.freeswitch.org/wiki/Variable%5Fexec%5Fafter%5Fbridge%5Farg "Variable exec after bridge arg")
* [execute\_on\_answer](https://wiki.freeswitch.org/wiki/Variable%5Fexecute%5Fon%5Fanswer "Variable execute on answer")

## execute_on_answer

在被叫方应答时执行一个应用程序（而不是API）。要设置一个API，请使用**api\_on\_answer**。**execute\_on\_answer**还允许在处理无应答情况时更好地控制，这种情况下，您无法忽略早期媒体。

该命令仅在尚未应答的通道上执行。只需使用export或以nolocal:前缀导出，以确保在b-leg应答时执行该命令。

在下面的第二个用法示例中，我们发起了一个外呼到一个本地分机，我们将在手动忽略媒体的情况下等待30秒。在这种情况下，我们使用 'set' 而不是 'export'。

用法:

```xml
<action application="export" data="nolocal:execute_on_answer=lua incrInUse.lua ${uuid}"/> 
```

或者，在等待30秒以获取答案时'手动'忽略早期媒体

originate {ignore_early_media=true}sofia/gateway/my_gateway/5551212 885551212

```xml
<extension name="exe_on_ans">
  <condition field="destination_number" expression="^88(\d+)$">
    <action application="set" data="execute_on_answer=transfer ANSWEREDCALL XML default"/>
    <action application="log" data="INFO Waiting 30 seconds for $1 to answer..."/>
    <action application="sleep" data="30000"/>
    <action application="log" data="INFO Call to $1 was not answered, taking alternative action..."/>
    <action application="transfer" data="UNANSWEREDCALL XML default"/>
  </condition>
</extension>
```

如果需要设置多个 execute_on_answer，以下语法允许为单个条件指定多个应用程序。例如:

&lt;action application="set" data="execute_on_answer_1=app1 arg"/>
&lt;action application="set" data="execute_on_answer_2=app2 arg"/>
&lt;action application="set" data="execute_on_answer_3=app3 arg"/>

## execute_on_media

当对方发送媒体时（例如振铃或183/SDP），执行一个应用程序。

该命令仅在尚未回答的通道上执行。只需使用 export 或带有 'nolocal:' 前缀的 export 来确保在 b-leg 回答时执行该命令。

在下面的第二个用法示例中，我们对本地分机发起了一个去电，我们会等待30秒钟而不忽略媒体。在这种情况下，我们使用 'set' 而不是 'export'。 
**用法:**

```xml
<action application="export" data="nolocal:execute_on_media=lua incrInUse.lua ${uuid}"/>
```

## execute_on_media_timeout

如果远端停止发送媒体并超时，则执行一个应用程序。

**用法:**

```xml
<action application="export" data="nolocal:execute_on_media_timeout=lua oops_timeout.lua ${uuid}"/>
<action application="set" data="execute_on_media_timeout=transfer HANDLE_MEDIA_TIMEOUT XML default"/>
```

## execute_on_originate

在成功发起后执行代码。使用 '`<app> <arg>`' 格式在发起线程中执行，或使用 '`<app>::<arg>`' 异步执行。

成功发起意味着远程服务器有响应，而不是呼叫实际上被接听。

**用法：**

originate {ignore_early_media=true,execute_on_originate='cng_plc'}sofia/gateway/foo/123456789 9664

originate {ignore_early_media=true,execute_on_originate='my_app::my_arg'}sofia/gateway/foo/123456789 9664

## execute_on_pre_answer

在被叫方“预答复”时执行一个应用程序（不是API），即当某种形式的早期媒体到来或远端发送180 Ringing时。

该命令仅在尚未接听的通道上执行。只需使用 export 或带有 `nolocal:` 前缀的 export，以确保在 b-leg 接听时执行。

在下面的第二个用法示例中，我们对本地分机发起了一个去电，我们会等待30秒钟而不忽略媒体。在这种情况下，我们使用 'set' 而不是 'export'。  
**用法：**

```xml
<action application="export" data="nolocal:execute_on_pre_answer=lua incrInUse.lua ${uuid}"/>
```

## execute_on_ring

当被叫方响铃时执行一个命令。  
**用法：**

```xml
<action application="set" data="nolocal:execute_on_ring=lua markring ${uuid}"/>
```

## export_vars

export_vars列出要在桥接时导出到另一条通路的变量。与[export](../../Modules/mod_dptools_1970333.mdx#-c)不同，它只列出要导出的变量，而不是实际设置它们。注意：这对于从a-leg（INVITE）传输信息到REFER的未来b-leg非常有用。

**另请参阅：**

* [Misc.\_Dialplan\_Tools\_export](../../Modules/mod_dptools_1970333.mdx#-c)

## fail_on_single_reject

当在桥接的DATA字段中使用"," AND运算符时，此选项非常有用。 AND运算符通知一系列目标，将呼叫桥接到第一个接受呼叫的目标。通常，如果列表中的一个目标拒绝呼叫，则会继续尝试桥接，直到另一个目标接受呼叫或超时发生。

此变量允许在单个呼叫拒绝时终止桥接尝试。这意味着桥接尝试将失败，如果没有设置continue_on_fail变量，则呼叫将被终止。此变量应在桥接应用之前的条件中设置。与continue_on_fail变量一起使用时，可以执行将呼叫拒绝者转接到答录机应用等操作。

默认设置为FALSE，意味着单个拒绝不会终止桥接尝试。

它还可以设置为[故障原因的列表](../../Troubleshooting-Debugging/Hangup-Cause-Code-Table_3964945.mdx#about)，以便停止，并且可以否定为停止其他故障原因的列表（即停止所有其他故障原因）。

**用法：**

```
<action application="set" data="fail_on_single_reject=true"/>
<action application="bridge" data="sofia/$${profile}/$${kitchen}%$${domain},sofia/$${profile}/$${dining}%$${domain}"/>
<action application="javascript" data="answermachine.js"/>
```

或者，

```
<action application="set" data="fail_on_single_reject=USER_BUSY"/>
```

或者，

```
<action application="set" data="fail_on_single_reject=!NORMAL_CIRCUIT_CONGESTION"/>
```

或者使用列表，

```
<action application="set" data="fail_on_single_reject=^^:CALL_REJECTED:NORMAL_CLEARING:USER_BUSY"/>
```

或者使用否定列表，

```
<action application="set" data="fail_on_single_reject=!^^:ALLOTTED_TIMEOUT:NETWORK_OUT_OF_ORDER"/>
```